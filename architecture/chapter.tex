\chapter{BLE positioning in practice}
\label{chap:architecture}

\wordcount{architecture}

Much research has been done on positioning using \wifi signals (ref: RADAR, EWKNN, etc), and many current \devices use the \wifi positioning system (WPS) to augment the GPS, or in places where GPS is not available.
WPS is based on measuring the signal strength of access points, and comparing these values with known values for different locations in the area.
The known values can be calculated using ray-tracing (RADAR), or can be surveyed at some earlier point in time.
The surveying for WPS was initially done from cars, and although this method of data collection still happens, manual submissions and usage of the system also feed surveying information back into the system\urlref{http://www.skyhookwireless.com/location-technology/coverage.php}.

It is important to differentiate between two types of location determination: \define{one-shot positioning}, where a single measurement is used to determine one's location, and \define{tracking}, where a set of measurements over time is used.
Tracking will obviously lead to higher accuracy, since the measurements can be related over time through business rules; for instance, when indoors it is unlikely that two measurements taken 1 second apart, were taken at more than three meters apart.
As another example, the algorithm may infer on which side of the road a \device is most likely to be, if it is moving along a road at a speed higher than cycling speed.
Even though most real-life applications are interested in tracking rather than one-shot positioning, a good one-shot algorithm is an essential basis for a tracking algorithm.

There is some research exploring using Bluetooth classic (not Low Energy) for positioning(refs); as chapter \ref{blepositioning} explains, Bluetooth Low Energy is a different protocol, which differs in many ways from Bluetooth classic, also on radio properties.
Even though the BLE PXP profile and iBeacons describe some sense of location awareness using BLE signals, they do not allow for absolute positioning.
I am also not aware of any academic papers describing positioning using BLE.

In this chapter I explore different strategies for positioning using BLE.
In addition to using the same methods that are being used for \wifi positioning, I propose, on the basis of the BLE radio propagation properties described in \chapterref{rss}, an improved BLE positioning algorithm: \BRP.
This improved algorithm performs 50\% better than the \wifi positioning algorithms.

\section{RSS based positioning}
\label{sec:architecture-rss-based-positioning}
There are multiple techniques for positioning using radio signals, such as Time-Of-Arrival (TOA), Angle-Of-Arrival (AOA) as Received Signal Strength (RSS).
No mainstream \devices have support for TOA or AOA for \wifi or Bluetooth Low Energy signals; they do all report RSS for \wifi and BLE signals\footnote{RSS for \wifi signals in iOS can only be retrieved by the positioning process in the OS itself, third party \apps do not have direct access to this data on not-jailbroken devices.}.

\citet{bahl2000radar} laid the foundation for positioning using \wifi signals.
The basis is a fingerprint database, containing fingerprints (the RSS, or RSS distribution, for each access point) for a large number of locations.
This database can either be filled empirically, surveying the RSS at each location; or calculated, where the RSS at each location is estimated using the positions of the access points and a radio propagation model for the environment.
The paper shows that empirically filling the database leads to better results, however it may take much longer since a manual survey of each location is needed.

To do positioning, a measurement of the RSS of each access point at an unknown location is made, and each fingerprint in the database is compared to this measurement in order to find one or multiple close matches.
The method mostly used to find a match is (a variant of) k-nearest-neighbour.
The method works in three steps.
Firstly the set of measured RSSs are transformed to a single RSS per access point for the measurements, and a single RSS per access point per location in the database; this latter part is usually done just once, during the surveying, but it may be beneficial to do this during the positioning step.
\citet{bahl2000radar} describes that the mean, standard deviation and median of multiple measurements at a single location was calculated, but only uses the mean in the rest of the paper.

Secondly the measured RSS is compared to that for all surveyed points, and the signal distance between the two points is calculated by a distance-function $L$.
The usual choice for the distance-function (and hence the name) is to calculate the distance in signal-space, where each signal-source is a dimension.
\citet{li2005method} described a generalised distance function
\begin{equation}
    L_q = \left(\sum_{i=1}^{n}|s_i-S_i|^q\right)^{\frac{1}{q}}
    \label{eq:architecture-distance}
\end{equation}
, where $n$ is the number of signal-sources, $s_i$ the measured RSS for a source, and $S_i$ the surveyed RSS at the point to which the distance is to be calculated; different $q$ lead to different distance functions with $L_1$ being the Manhattan distance, and $L_2$ the Euclidean distance.
There seems to be no clear consensus on which $q$ gives the best result, with \citet{shin2012enhanced} using $L_1$, \citet{bahl2000radar} using $L_2$, only saying that alternatives (possibly also of another form) were briefly experimented with, and \citet{li2005method} using $L_1$, while noting that the difference with other $q$ values is not significant.
Most methods use the $L_q$ function with the $s_i$ in dB, \citet{li2005method} explores whether the $s_i$ should alternatively use the power $P$, $1/P$, $1/P^2$ or $1/P^4$, concluding that dB works the best, but $1/P^2$ and $1/P^4$ also give good results.

Finally the calculated distances are being used to map to a position.
\citet{bahl2000radar} uses both a 1-nearest-neighbour and a k-nearest-neighbour approach, showing that the second works better (although only slightly due to some choices they made in the rest of the algorithm).
\citet{li2005method} uses a weighted-k-nearest-neighbour approach, where the nearest neighbours are being weighted by the result of the distance-calculation, and \citet{shin2012enhanced} introduced using a dynamic value for the number of neighbours $k$ to further improve the result.

\section{Positioning using BLE}

\section{Experiment}
\fig{\gnuplot{architecture}{room}{Test bed: room SW02 in the Computer Laboratory of the University of Cambridge.}}
Room SW02 in the Computer Laboratory of the University of Cambridge is the test bed for this experiment.
The room consists of a square 12 by 12 meter main area, with several coves.
The room contains four decagonal-shaped tables with computers on them and chairs around them, as well as some other furniture.
Twenty BLE beacons were used, ten on the walls of the room, eight on the tables, one in the middle and one placed a couple of meters outside the room (\figureref{architecture}{room}).
The beacon positions were chosen such that all areas would receive BLE signals, but no specific action was taken to find optimal positions.
Each beacon sends a single advertising packet, a unique beacon ID, on all three advertising channels every 100 ms; the transmitting power of a single beacon stays the same over its lifetime.
All measurements were done on a 60 by 60 cm grid, since this is the size of the floor tiles.

During the surveying phase, each accessible point on the grid is surveyed, by slowly moving the \device along a circle with a radius of 15 cm centred on the grid point, the back of the phone facing outwards, with a human body on the opposite side of the circle, facing the screen; the normal position for a user using the \device.
For each advertisement packet received, the beacon ID, advertising channel, RSS and the current heading as reported by the \device's compass, is saved.
Complete 360\textdegree{} survey took between 3.5 and 15 seconds for each of the 226 accessible points, with an average of 9 seconds per point.
On average 903 advertising packets were captured per point\footnote{With each of the twenty beacon advertising on all three channels at 10 Hertz, $3 \times 10 \times 20 = 600$ advertisements per second are broadcast. Since a \device only listens at one channel at a time (quickly switching between the three channels), a maximum of 200 advertisements per second can be received. Because of the time needed for switching between the channels, and collisions of packets, I consistently received around 100 advertisements per second on my \device.}.

During the positioning phase, a test subject was asked to go to a particular grid point, stand still while holding the phone ``naturally'', with the phone held still over the grid point, and log the beacon ID, advertising channel, RSS and current heading for each packet received for two seconds.
On average 200 packets were received per measurement, and each accessible point was visited three times\footnote{Some points on the side of the room were actually only visited twice, however this doesn't influence the results.}.

(say something about beacons that cannot be heard)

It should be noted that both in the surveying and the positioning phase, for about 2\% of all packets no RSS information was reported by the OS; these packets were discarded.

In addition the $x$, $y$ and $z$ coordinates for each beacon were determined, and the maximum RSS on 1 meter distance.

The data gathered from this experiment allows me to compare five different positioning algorithms, and simulate how they perform under different circumstances.
For access to the raw data, see \appendixref{rawdata}.

\section{Positioning methods}

All positioning in this report is being done through the weighted k-nearest-neighbour algorithm.
Provided a set of distances for a single measurement to each surveyed point, ordered by distance, the average of the points belonging to the first $k$ distances is calculated, weighted by $\frac{1}{distance+\epsilon}$.
The difference between the compared algorithms is how the distances are calculated, the first two steps of the nearest-neighbour algorithm as described in \sectionref{architecture}{rss-based-positioning}.
(say something about the choice of $k$)

\subsection{Random}
As a reference, the random method returns a distance randomly.

\subsection{Signal Space Distance (SSD)}
The method described in \citet{bahl2000radar}, using dB for the RSS, and the $L_2$ distance function (\equationref{architecture}{distance}).
As in \citet{bahl2000radar}, the mean RSS over all received packets is used both in the surveying and the positioning data.
Only one fingerprint per position is taken, unlike \citet{bahl2000radar}, which creates four fingerprints, one in each direction.

\subsection{Signal Space Distance with Orientation (SSD-O)}
This method uses the same distance function as SSD, however uses the orientation information compare only to results in the same orientation.
The mean orientation as reported by the \device's compass during the positioning measurement is being used to generate a fingerprint database on the fly, which contains the average RSS measured in that orientation + or - 30 \textdegree{}.
This differs from the method used in \citet{bahl2000radar}, firstly because they only used four directions, secondly because they needed to match a measurement against all four possible directions, while this method takes advantage of the fact that the \device knows its orientation.
(This method is sensitive to irregularities in compass reading)
(offset position by 0.25 tile?)

\subsection{\BRP (\aBRP)}
\BRP uses a distance function that takes advantage of the radio propagation properties of Bluetooth Low Energy, such as we have seen in \chapterref{rss}.
In this context it intuitively makes more sense to talk about a ``penalty function'' in stead of a distance function, since what it calculates is not the distance in any multi-dimensional space, but rather adds penalties for differences between the measured and surveyed RSS.
This semantic difference does not change its function however, penalties are calculated for each fingerprint in the database, and the ones with the lowest penalties are selected to be averaged.

\BRP recognises that, once during surveying the maximum RSS in an area has been determined, it is very unlikely that during positioning a much higher RSS will be measured at that point.
This means that $s_i \gg S_i$ (where $S_i$ is the value stored in the fingerprint and $s_i$ the value measured, for beacon $i$) should result in a large penalty.
On the other hand, having measured a much lower RSS may be the result of \mpi, antenna orientation or body shadowing, and is not a strong indicator that a particular position should be discarded; hence $s_i \ll S_i$ should not carry a large penalty.

The above is only true if the surveyed RSS is not influenced by \mpi, antenna orientation or body shadowing; to assure this the fingerprint takes the maximum RSS (as opposed to the mean in the SSD methods) found during the surveying, and surveying is being done while rotating and moving the \device in a circle, thereby minimising the chance that the maximum RSS surveyed is not the maximum in the area.
If something changes in the environment making it likely that the maximum has changed (for instance furniture that was blocking the direct signal before, was moved), the location should be surveyed again.
Positioning measurements also use the maximum RSS compare against the fingerprints.

The following punishment function was found to work well, however could possibly be refined, as long as the properties above hold.
\begin{equation}
    L = \begin{cases}
        |S_i - s_i| \times 1000     & \text{if } s_i - S_i > 3 \\
        |S_i - s_i|                 & \text{if } 0 < s_i -S_i \leq 3 \\
        |S_i - s_i| \times 0.125    & \text{if } s_i-S_i \leq 0 
    \end{cases}
    \label{eq:architecture-BRP-punishment}
\end{equation}

\subsection{\BRP with Radio Propagation Model (\aBRP-RPM)}
Whereas \aBRP uses a surveyed database of fingerprints, \aBRP-RPM estimates the maximum RSS on a specific location using a radio propagation model.
\citet{bahl2000radar} describes a radio propagation model used for \wifi signals, which uses the layout of the building, and a Wall Attenuation Factor to estimate RSS at different locations.
Such a model does not work well for \aBRP however, since \aBRP expects the fingerprints to be the maximum receivable RSS in that area, and the model in \citet{bahl2000radar} tries to have a low average error.
In stead I use a simplified model for maximum expected RSS at a position.

Knowing that RSS is in decibel of the power, and the power decreases quadratically with distance, one can calculate the RSS $R(x)$ for a radio signal in empty space at distance x from the transmitter, if the RSS at 1 meter distance $R_0$ is known.
\begin{equation}
    R(x) = R_0 - 10 \times \, ^{10}\log(x^2) = R_0 - 20 \times \, ^{10}\log(x)
\end{equation}

By measuring the RSS at one meter for each beacon (if all beacons are similar, this only has to be measured for one beacon), this formula can be used to estimate the maximum RSS at any location.
I filled the fingerprint database with RSS calculated this way at a height of 120 cm, the same as used for surveying, and roughly the height at which a \device is naturally held.
It should be noted that \mpp can result in the actual RSS in a spot being higher than the one estimated this way, however this is seldom more than 3 dB, and \equationref{architecture}{BRP-punishment} already allows for this, only adding severe penalties for more than 3 dB difference.

\section{Measurements}
\fig{
    \begin{subfigure}[b]{0.5\textwidth}
        \gnuplotscale{architecture}{heatmap-f-mean}{mean (SSD)}{0.55}
    \end{subfigure}
    \begin{subfigure}[b]{0.5\textwidth}
        \gnuplotscale{architecture}{heatmap-f-rot-0}{mean, direction north (SSD-O)}{0.55}
    \end{subfigure}
    \begin{subfigure}[b]{0.5\textwidth}
        \gnuplotscale{architecture}{heatmap-f-max}{maximum (\aBRP)}{0.55}
    \end{subfigure}
    \begin{subfigure}[b]{0.5\textwidth}
        \gnuplotscale{architecture}{heatmap-f-rpm}{estimated (\aBRP-RPM)}{0.55}
    \end{subfigure}
    \caption{Each method uses its own fingerprint database; shown the RSS of the central beacon in each database}
    \label{fig:architecture-heatmaps}
}

\Figureref{architecture}{heatmaps} shows the RSS for a single beacon in the different fingerprint databases.
The RSS looks as expected; RSS generally decreases with distance to the beacon.
The SSD-O fingerprint has slightly higher averages than the SSD south of the beacon, and slightly lower north of the beacon, because of body shadowing.
The maximum is about 10dB higher than the average (this is generally consistent with the results from \figureref{rss}{mpi-combine-channels}).
(todo: say something about rpm).

\subsection{Signal Space Distance}


